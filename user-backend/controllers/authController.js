const status = require('http-status');
const { check, validationResult } = require('express-validator/check');
const { sanitizeBody } = require('express-validator/filter');
const bcrypt = require('bcryptjs');
const SALT_ROUND = 10;
const salt = bcrypt.genSaltSync(SALT_ROUND);
const User = require('../models/userModel');

/**
 * check the user exist in the database, if exist
 * pass the user for next middleware
 *
 * @param {Object} email - Email ID of user
 * @param {Object} password - Password of user
 * @param {Function} cb - Callback, takes (err, result)
 * @return {undefined}
 */
const verifyValidUser = (email, password, cb) => {
  if (!email || !password) return cb('Username or password not present');

  User.findOne({ email: { $in: [email] } }).exec((err, user) => {
    if (err) return cb({ error: 'Database error occurred' });
    if (!user) return cb({ error: 'Invalid credentials' });

    comparePassword(password, user.password)
      .then(ismatch => {
        if (ismatch) {
          const { password, ...sensitiveUser } = user._doc;
          return cb(null, sensitiveUser);
        } else {
          return cb({ error: 'Invalid credentials' });
        }
      })
      .catch(err => {
        return cb({ error: 'Retry again something went wrong...' });
      });
  });
};

/**
 *Checks user with a given email or username exist in the database
 * If no duplicate entry, call next() middleware
 *
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @param {Function} next - Express next middleware
 * @return {undefined}
 */
const checkDuplicateUser = (req, res, next) => {
  User.findOne({
    $or: [{ email: req.body.email }, { username: req.body.username }]
  }).exec((err, user) => {
    if (user) {
      res.status(status.CONFLICT).json({ msg: 'User already exist' });
    } else {
      next(); //new user
    }
  });
};

/**
 * bcrypt hash a given text input using a bcrypt salt
 *
 * @param { String } password client provide
 * @param { SALT } saltValue generated by bcrypt
 * @return { Promise }
 */
const hashPassword = (password, saltValue) => {
  return new Promise(resolve => {
    return resolve(bcrypt.hash(password, saltValue));
  });
};

/**
 *bcrypt compare of a hashed password with plain text 

 * @param { String } passwordInput provided by a client
 * @param { hash } storedPassword hash stored in database or some file
 * @return { Promise }
 */
const comparePassword = (passwordInput, storedPassword) => {
  return new Promise(resolve => {
    return resolve(bcrypt.compare(passwordInput, storedPassword));
  });
};

/**
 *
 * replace req.body.password property value to hashed version
 * and calls next middlware with the modfied request object
 *
 * @param { Object } req express Request object
 * @param { Object } res express response object
 * @param { function } next middleware Function
 * @return { Undefined }
 */
const saveHashPassword = (req, res, next) => {
  hashPassword(req.body.password, salt)
    .then(value => {
      req.body.password = value;
      next();
    })
    .catch(err => {
      res
        .status(status.INTERNAL_SERVER_ERROR)
        .json({ msg: 'Server Error ....' });
    });
};

/**
 * check user.req data from decoded token exist in the database
 * if exist call next middleware
 *
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @param {Function} next - Express next middleware
 * @return {undefined}
 */
const matchDecodedUserWithDb = (req, res, next) => {
  const userProfile = JSON.parse(req.header('userProfile'));
  const user = userProfile.user;
  User.findOne({ _id: user._id }, (err, user) => {
    if (!user) {
      res.sendStatus(status.UNAUTHORIZED);
    } else {
      req.user = user;
      next();
    }
  });
};

//check admin previlage
//can be use with matchDecodedUserWithDb for extra security
const checkAdminRole = (req, res, next) => {
  const userProfile = JSON.parse(req.header('userProfile'));
  const user = userProfile.user;
  if (!user || !user.role || user.role !== 1) {
    return res
      .status(status.UNAUTHORIZED)
      .json({ error: 'Current user does not have sufficient permissions' });
  } else {
    return next();
  }
};

/**
 * Checks any request that has user _id originate from
 * admin, if not admin checks that user role === 0,
 * and that user is using its own _id to make the request
 *
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @param {Function} next - Express next middleware
 * @return {undefined}
 */
const verifyRequestWithId = (req, res, next) => {
  const userProfile = JSON.parse(req.header('userProfile'));
  const user = userProfile.user;
  if (user) {
    if (user.role === 1) {
      req.loggedInUser = user;
      req.loggedIn = userProfile.loggedIn;
      next();
    } else if (user.role === 0 && user._id && user._id === req.params._id) {
      req.loggedInUser = user;
      req.loggedIn = userProfile.loggedIn;
      next();
    } else {
      return res
        .status(status.UNAUTHORIZED)
        .json({ error: 'Current user does not have sufficient permissions' });
    }
  } else {
    return res
      .status(status.UNAUTHORIZED)
      .json({ error: 'User must be loggedin' });
  }
};

/**Profile update validators */
const profileUpdateValidators = [
  sanitizeBody('*')
    .trim()
    .escape(),

  //check firstName and lastName
  check(['firstName', 'lastName'])
    .optional({ checkFalsy: true })
    .isAlpha()
    .withMessage('Names should be letter'),
  //check email
  check('email')
    .exists()
    .isEmail()
    .withMessage('Provide valid email')
];
/**Password update validators */
const passwordUpdateValidators = [
  //sanitize globally
  sanitizeBody('*')
    .trim()
    .escape(),
  check('password')
    .exists()
    .withMessage('Provide valid password')
];
/**
 * array of middleware login validators
 */
const loginValidators = [
  //sanitize globally
  sanitizeBody('*')
    .trim()
    .escape(),

  //check password
  check('password')
    .exists()
    .withMessage('Provide valid email or password'),

  //check email
  check('email')
    .exists()
    .isEmail()
    .withMessage('Provide valid email or password')
];

const signupValidators = [
  //sanitize globally
  sanitizeBody('*')
    .trim()
    .escape(),

  //check firstName and lastName
  check(['firstName', 'lastName'])
    .optional({ checkFalsy: true })
    .isAlpha()
    .withMessage('Names should be letter'),

  //check username
  check('username')
    .exists()
    .withMessage('provide valid username'),

  //check role
  check('role')
    .optional({ checkFalsy: true })
    .isNumeric()
    .withMessage('Role should be numeric'),

  //check email
  check('email')
    .exists()
    .isEmail()
    .withMessage('Provide valid email'),

  //check password
  check('password')
    .exists()
    .withMessage('Password should not be empty')
];

/**
 * Middleware to check for errors from
 * middleware validation
 */
const checkValidationResult = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    res.status(status.BAD_REQUEST).json(
      errors.array().map(err => {
        let { msg, ...y } = err;
        return msg;
      })
    );
  } else {
    next();
  }
};

module.exports = {
  verifyValidUser,
  checkDuplicateUser,
  matchDecodedUserWithDb,
  checkAdminRole,
  verifyRequestWithId,
  loginValidators,
  signupValidators,
  passwordUpdateValidators,
  profileUpdateValidators,
  checkValidationResult,
  saveHashPassword,
  comparePassword,
  hashPassword
};
